# `Corgi` in more details...

In this section we give a more detailed view on the features and functionality of `Corgi`. We
recommend first have a look at our [introductory example](../README.md#corgi-by-example) before
exploring this page.

## Overview

`Corgi` is a code generator for Smart Contracts written in Solidity. The main purpose of `Corgi` is
to offer a handy tool for introducing role-based access control to Smart Contracts. While the
concept of role-based access control appears intuitive, an naive implementation runs into danger
of being erroneous and/or inefficient. While the first one would be a problem for any platform,
the latter one is especially problematic for Smart Contracts as inefficient code leads to
high costs in production. Hence, Corgi strives for an easy-to-use interface while ensuring that the code generated is efficiently enough to be usable in practice.

### Role Based Access Control

Role based access control (or _RBAC_) is a way of managing access to resources or functions in a
system with authentication already in place. Hence, we are not concerned with identifying users
but rather define their permissions in the system.

In RBAC, users get assigned one or multiple roles where each role ensures a set of permissions.
Usually, roles are in relation to each other by a hierarchy. These hierarchy will be called
OrgChart (organizational chart) here.

### What is an OrgChart?

An OrgChart is basically a DAG (<u>D</u>irected <u>A</u>cyclic <u>G</u>raph) representing
a hierarchy of roles. Each vertex of the graph represents a role, and an edge between two
nodes describe the relation of the two roles: Given a node `A` and a node `B`, the
directed edge `(A,B)` says that the role `A` is a senior role of `B` (or equally, that
role `B` is a junior role of `A`).

The hierarchy implicitly describes an inheritance of permissions. In general, it is assumed
that senior roles inherit their permissions from junior roles. Hence, any resource or function
accessible by role `B` is generally assumed to be accessible by role `A` if `B` is a junior
role of `A`. This inheritance allows defining complex permission systems.

### Granting and Revoking Roles

An OrgChart only defines the hierarchy of roles. The contracts generated by `Corgi` however
also take care of the assignment from users to roles. Assigning a user to a new role is called
_granting a role_ and is done additively. Hence, granting a role to a user adds the role to
the set of the user's roles (and not overwriting it). If a role is removed from a user's set of
roles, it is called _revoking a role_.

Both granting and revoking of a role is defined via rules. These rules specify a set of
required approvals from different roles. For example, a rule for granting role `A` could
require, that one person with role `B` and two persons with role `C` approve. `Corgi` offers
an expressive rule-specification language. For more details, have a look at the
[language pages](./LANG.md).

### Querying and Role Inheritance

Besides keeping track of the user-to-role assignment, the contracts generated by `Corgi` also
allow for efficient querying of that relation. More specifically, we expect our OrgCharts to
decide the property `hasRole(U, R)` for any user `U` (where `U` is some identifier of the user,
like, for example, the address) and any role `R` such that `hasRole(U, R)` is `true` if user `U`
has the role `R` and `false` otherwise.

While a direct user-role assignment is easy to
decide efficiently, it becomes more interesting when role inheritance is involved: For example,
consider a role `A` and a role `B` such that role `B` is a junior role of role `A`. Now
if a user `Bob` gets assigned role `A`, we expect the contract to evaluate `hasRole(Bob, A)` to `true`.
However, as `A` is a senior of `B`, it should also be the case that `hasRole(Bob, B)` evaluates to
`true`.

In some use cases, however, we might want to see the user-to-role assignment in a stricter sense:
We may also want to decide if a user was directly assigned to a role. As mentioned, this property
is usually easier to decide efficiently. We will denote this property with `hasStrictlyRole(U, R)`
where `U` and `R` have the same meaning as before.

> _**Note:** When we say "efficient" we **do not** talk about efficiency in a complexity theoretical sense,
> where "efficient" usually refers to a problem being solvable in polynomial time. Instead, we are concerned
> with efficiency in practice on EVM-compatible platforms, where efficiency is usually defined in terms of low
> gas costs._

## The OrgChart

`Corgi` differs between two type of OrgCharts:

- **standard OrgCharts**
- **dynamic OrgCharts**

Standard OrgCharts are defined once at creation time. Once deployed, the structure of the
OrgChart can no longer be changed. This means:

- No role can be added or removed
- No rule for granting or revoking roles can be added or removed
- User-to-Role assignments can, however, be changed through grant- and revoke-requests

Contrary, dynamic OrgCharts allow for new roles being added after deployment. However,
this comes at the cost of a performance loss and hence more expensive transactions.

The standard OrgChart (most importantly) supports the following methods:

- `hasRole(address user, bytes32 roleId): bool`:
  Returns `true` if `user` is assigned to the role corresponding to `roleId`, considering inheritance.
- `strictlyHasRole(address user, bytes32 roleId): bool`:
  Return `true` if `user` is directly assigned to the role corresponding to `roleId` and hence
  ignoring the inheritance.
- `grantRole(SignedApproval approval, address nominee, bytes32 roleId)`:
  Grants the role corresponding to `roleId` to the user with address `nominee` if the passed
  `approval` is valid, i.e., if (one of) the grant-rule(s) for role `roleId` was fulfilled.
- `revokeRole(SignedApproval approval, address nominee, bytes32 roleIid)`:
  Revokes the role corresponding to `roleId` from the user with address `nominee` if the passed
  `approval` is valid, i.e., if (one of) the revoke-rule(s) for role `roleId` was fulfilled.

We will later explain in more detail how the validation of approvals is done. For now, let us
just assume that a valid approval expresses that a grant- or revoke-rule was fulfilled.

The dynamic OrgChart extends the list by two further methods:

- `addRole(SignedApproval approval, RoleDef roleDef)`:
  Adds a new role to the OrgChart according to `roleDef` if the passed `approval` is valid, i.e.,
  if (one of) the admin-rule(s) was fulfilled and the new role does not violate any validation
  rules (e.g., introducing a cycle; more on that later).
- `removeRole(SignedApproval approval, bytes32 roleId)`:
  Removes the role corresponding to `roleId` from the OrgChart if the passed `approval` is valid,
  i.e., if (one of) the admin-rule(s) was fulfilled and the role exists.

### Rules

`Corgi` knows three type of rules already mentioned shortly before:

1. **Grant-Rules:** Used for defining rules for assigning a role to a user
2. **Revoke-Rules:** Used for defining rules for removing a role from a user
3. **Admin-Rules:** Used for defining rules for adding and removing roles

For each role, there can be multiple grant- and revoke-rules. Having multiple grant- (resp. revoke-)rules for
one role is interpreted as a _disjunction_ of rules, i.e., in order to grant (resp. revoke) the specified
role, it is sufficient to fulfill one of these rules.

Similar, an OrgChart can define multiple admin-rules. Here, for adding or removing a role from the OrgChart,
it is also enough to fulfill one of the specified admin rules.

A grant-, revoke- or admin-rule consists of a list of rule-atoms:

$$R_1(n_1), ..., R_m(n_m)$$

where $R_i(n_i)$ is a rule-atom s.t. $n_i$ is a strictly positive natural number or a percentage
of the form $k\%$ where $k$ is a natural number with $1 \leq k \leq 100$ and $R_i$ is either a
role $R$ or $!R$ (strictly $R$).

The list of quantified role-atoms is interpreted by `Corgi` in an conjunctive manner. For example,
if the grant rule for a role $C$ would be $A,B$, it would mean that one user with role $A$ and
one user with role $B$ has to approve the request. For more details on how to express these
rules in `orglang` have a look [here](./LANG.md).

> **The special role `self`:**
> For grant- and revoke-rules, a special role can occur: The `self` role. This role specifies
> that the nominee of the role (or the user who should be revoked from a role) also has to
> sign the request.

### Requests

Grant-, revoke- and admim-rules have to be validated whenever a _request_ is performed.
Corresponding to the rules, `Corgi` knows three types of _requests_:

1. **Grant-Request**: A request for giving a certain role to a user
2. **Revoke-Request**: A request for taking away a role from a user
3. **Admin-Request**: A request for adapting the org-chart (adding or removing roles)

Obviously, admin-rules and admin-requests only occur in the context of dynamic OrgCharts. Requests
can be performed by anyone by calling the corresponding methods of the OrgChart:

1. For grant-requests, one has to execute the `addRole` function
2. For revoke-requests, one has to execute the `removeRole` function
3. For admin-requests, one either calls the `addRole` function or the `removeRole` functions
   depending on the action they want to perform.

Obviously, the OrgChart cannot just accept any request. Instead the request has to come with an
approval of a set of users that have the needed roles according to the corresponding rules.
As mentioned before, there can be multiple possible rules that can be applied to an action.
For example, for granting role `A` there could be two rules defined. Here, the request-performing
user has to specify to which of the allowed rules their request should be checked against.

### Approving a request

In `Corgi`, an approval for a request is expressed by signatures:
In order to grant, revoke and add or remove a role, one first has to collect all
necessary signatures from users according to their roles and the rule for the request.
This collection of approvals is represented by the structure `SignedApproval` and contains
the following information:

- `sig`: A list of signatures of each approving user
- `atoms`: A list of rule-atoms, i.e., the used rule
- `assignment`: An n:1 assignment from signers to rule-atoms representing which signer
  has signed with which role
- `selfSignRequired`: Specifies if the rule demands the nominee to sign (must be `false`
  in case of admin-rules)
- `baseBlockHash`: Base-Block, which needs to be at most 3 blocks behind the current block in
  order to avoid replay-attacks.

It is important to note that it is not the `SignedApproval` that is signed but the request
(which is different for grant-, revoke- and admin-requests; more on that later). This structure
only contains the signatures and the data necessary for validating the signature on-chain.

Interestingly, the approval contains the whole specification of the rule (the fields `atoms` and
`selfSignRequired`). This is because the OrgChart contract never stores the rule itself on-chain.
However, to avoid users choosing an arbitrary rule, the OrgChart secures only the hash of the
rule on-chain. This reduces storage costs as `calldata` storage is much cheaper then actual storage.

On submitting the approval for any request (grant, revoke, add or remove role), the OrgChart first
validates that the rule specified exists and that it can be used for the attempted request.
For example, if an approval is submitted for grant-request of role `A`, the OrgChart first checks if the
specified rule can be used for granting role `A`.

Another field worth explaining is the `assignment`: Note that it is in general non-trivial
to decide, given a set of signers and their roles, who needs to sign using which role. This is
due to the fact that senior roles can sign for their junior roles (inheritance) and because
two roles might be incomparable regarding "seniority". For more details have a look
[here](./ADVANCED.md#flow-network).

For avoid replay attacks where an attacker sends again the same approval, we have added the
`baseBlockHash`. An other option would be to introduce a `nonce`, however this introduces a
bottleneck. The idea of the `baseBlockHash` is to bind the signature to a block hash that must
appear with in the last three blocks of the current block for the signature to be valid.
In theory, this still allows for replay attack that are shortly timed. However, if we consider
the requests, they are not likely to be successfully replayed shortly after another: If one
successfully revokes a role `A` from a user `U`, revoking it again shortly after will most likely
not be successful as first, one would have to grant the role `A` again to user `U`.

### Signing a Request

The signing of a request works slightly differently for grant- and revoke-requests and admin-
requests. For a detailed description of how the signed data is structured, have a look
[here](./SIGNING.md). In this section we only give a high-level overview.
Note that currently, `Corgi` does not come with a signing tool. However, we plan to add
such a feature for future releases.

For granting and revoking a role, the signing works the same: First a hash of the
request is computed. This is done by the hash function `h1(nominee, action, role, baseBlockHash)`.
The `nominee` is the address of the effected user. The action defines the kind of request, i.e.,
if it is a grant- or a revoke-request. The `role` specifies the role that should be granted or
revoked. Finally, the `baseBlockHash` is the hash of the block that must be in the short-term
history of the current block for preventing replay-attacks as described before.

By signing `h1(nominee, action, role, baseBlockHash)`, the signer expresses her agreement with the
request. All the signatures are then collected together in the `SignedApproval` structure as
described before.

Signing admin requests is slightly different as the hash function changes. Also, we have
different hash functions for adding and removing role:
For adding a role, the hash function looks as follows:
`h2(role, roleFlag, seniorFlags, juniorFlags, rules, baseBlockHash)`.
The `role` simply specifies the identifier for the role. The fields `roleFlag`, `seniorFlags` and
`juniorFlags` are a bit harder to explain without going into too much details but basically they
describe where in the graph the new role should be added. For more details have a look
at the [ADVANCED.md](./ADVANCED.md) file. The field `rules` contains a list of grant- and revoke-rules
for the new role. Finally, the `baseBlockHash` serves the same purpose as before.

For removing roles, the hash function becomes much simpler as we only need to specify the role that
should be removed: `h3(role, baseBlock)`.
From there, the signing process works as before: Signers express there approval by signing the hash
of the request. The signatures are then collected together in the `SignedApproval` structure.

Note that the hash function `h1`, `h2` and `h3` are just placeholders for a sequence of hash
operations on the data passed to these function. In particular, these function not just simply
hash the data they get passed using a single call to a lower-level hash function like `keccack`.
Instead, hashing structured data has to be applied carefully to avoid hash-collisions.
For a more detailed insight in how the signatures are crafted have a look [here](./SIGNING.md).

### Representing the OrgChart and Other Design Principles

When choosing a data structure for representing the OrgChart on-chain, we have to consider two
main metrics:

1. The storage needed
2. The computational complexity for querying user-to-role assignments

We think that both requirements are best met by using bit-vector labeled DAGs. We will not go
into details here (and instead refer to the [CONCEPTS.md](./ADVANCED.md)) but the basic idea is
to encode the structure of the OrgChart in bit-vectors. Queries like _"Is role `B` a junior of
role `A`"_ can then be answered in constant time by the use of bit-operations.

Another design principle was to shift parts of the data needed from the storage to calldata, i.e.,
just let the user pass it together with the request when needed. To avoid manipulation, the
data is simply anchored in on-chain. This reduces storage costs but of course increases
computational complexity (and hence gas costs). However, our experiments have shown that
the saved storage compensates for the additional gas costs.
